#!/bin/bash

# ========== Tested in the following environment ==========
# GNU bash, version 5.3.0(1)-release
# gpg (GnuPG) 2.4.9
# libgcrypt 1.11.1-unknown
# pinentry-gnome3 (pinentry) 1.3.2-unknown

RED="\e[31m [ERROR] "
GREEN="\e[32m"
YELLOW="\e[33m [WARNING] "
ENDCOLOR="\e[0m"

usage() {
    echo "Usage: $0 <file>"
    echo
    echo "A simple secret manager designed to minimize plain-text storage on the SSD"
    echo "Supports encrypt-after-edit and decrypt"
    echo
    echo "Arguments:"
    echo "  <file>       The target file (e.g., topsecret.asc)"
    echo
    echo "Options:"
    echo "  -h, --help   Show this help message and exit"
    exit 1
}


# =============== Helper ===============
goto_shred () {
    shred -u "$tmpfile"
    ret=$?
    if [ $ret -ne 0 ]; then
        echo -e "${RED}Failed to shred '$tmpfile'${ENDCOLOR}"
        echo -e "${RED}Please securely remove the file yourself! ${ENDCOLOR}"
    fi
}


# =============== Check argument ===============
if [ $# -lt 1 ]; then
    usage
fi

if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    usage
fi

if [ ! -f "$1" ]; then
    echo -e "${YELLOW}File '$1' not found.${ENDCOLOR}"
    read -p "Do you want to create a blank gpg file? (y/n) " choice
    case $choice in
        [Yy]* )
            tmpfile=$(mktemp /dev/shm/tempfile.XXXXXX)
            pw=$(uuidgen | tr -d '-' | cut -c 1-8)
            fn=$(uuidgen | tr -d '-' | cut -c 1-10)
            gpg -a -c --batch --yes --passphrase "$pw" --pinentry-mode loopback \
                 -o "$fn".asc "$tmpfile"
            echo -e "${YELLOW}Blank gpg file '$fn.asc' has been created.${ENDCOLOR}"
            echo -e "${YELLOW}Password: '$pw'${ENDCOLOR}"
            echo -e "${YELLOW}Change the password immediately!!!${ENDCOLOR}"
            goto_shred
            exit;
        ;;   
        [Nn]* )
            echo -e "${GREEN}OK then. Bye bye!${ENDCOLOR}"
            exit;
        ;;   
        [*]* )
            echo -e "${RED}Invalid input!!!${ENDCOLOR}"
            exit;
        ;;
    esac  
fi

tmpfile=$(umask 077 && mktemp /dev/shm/tempfile.XXXXXX)
gpgfile="$1"

while true; do
read -p "Encrypt-after-edit or Decrypt? (e/d) " choice
    case $choice in
        [Ee]* )   
            gpg --yes -v -o "$tmpfile" -d "$gpgfile"
            ret=$?
            if [ $ret -eq 0 ]; then
                checksum_old=$(sha256sum "$tmpfile" | awk '{print $1}')
                vim -n -c 'set noswapfile noundofile nobackup nowritebackup' "$tmpfile"
                checksum_new=$(sha256sum "$tmpfile" | awk '{print $1}')
                if [ "$checksum_new" != "$checksum_old" ]; then
                    gpg -v -a -c -o "$gpgfile" "$tmpfile"
                    ret=$?
                    if [ $ret -eq 0 ]; then
                        echo -e "${GREEN}Successfully encrypted to '$gpgfile'!${ENDCOLOR}"
                    else
                        echo -e "${RED}Failed to encrypt to '$gpgfile'!${ENDCOLOR}"
                    fi
                else
                    echo -e "${YELLOW}No change is made.${ENDCOLOR}"
                fi
            else
                echo -e "${RED}Failed to decrypt '$gpgfile'!${ENDCOLOR}"
            fi
            goto_shred
            break
        ;;
        [Dd]* )
            # default-cache-ttl=600
            gpg -v -o/dev/null -d "$gpgfile" &&
            ret=$?
            if [ $ret -eq 0 ]; then
                echo -e "${GREEN}Successfully decrypted!${ENDCOLOR}"
                sleep 0.5
                gpg -q -d "$gpgfile" | LESSHISTFILE=- less
            else
                echo -e "${RED}Failed to decrypt '$gpgfile'!${ENDCOLOR}"
                exit;
            fi
            break
        ;;
        * ) echo -e "Please answer e or d";;
    esac
done
